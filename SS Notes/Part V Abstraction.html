<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Part V Abstraction</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="SS Notes/github-pandoc.css" />
</head>
<body>
<header>
<h1 class="title">Part V Abstraction</h1>
</header>
<p><strong>What are the two kinds of abstraction specified in this part?</strong></p>
<ul>
<li>data abstraction</li>
<li>the implementation of higher-order functions</li>
</ul>
<h2 id="chapter-17-lists">Chapter 17 Lists</h2>
<p><strong>How to use list to define an icecream menu?</strong></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb1-1" title="1">(vanilla (ultra chocolate) (heath bar crunch) ginger (cherry garcia))</a></code></pre></div>
<p>This is meant to represent five flavors, two of which are named by single words, and the other three of which are named by sentences.</p>
<p>The data structure we’re using in this example is called a <strong><em>list</em></strong>.</p>
<p><strong>What are the differnces between a sentence and a list?</strong></p>
<table>
<thead>
<tr class="header">
<th></th>
<th style="text-align: center;">lists</th>
<th style="text-align: center;">sentences</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>elements</strong></td>
<td style="text-align: center;">anything</td>
<td style="text-align: center;">words</td>
</tr>
<tr class="even">
<td><strong>definition</strong></td>
<td style="text-align: center;">sefl-referential</td>
<td style="text-align: center;">non-self-referential</td>
</tr>
</tbody>
</table>
<p>A list that’s an element of another list is called a <strong><em>sublist</em></strong>. We’ll use the name <strong><em>structured</em></strong> list for a list that includes sublists.</p>
<p><strong>How to use lists in pattern matcher?</strong></p>
<p>We used list structure to hold known-values databases, such as</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb2-1" title="1">((FRONT (YOUR MOTHER)) (BACK (SHOULD KNOW)))</a></code></pre></div>
<p><em>Lists are at the core of what Lisp has been about from its beginning. (In fact the name “Lisp” stands for “LISt Processing.”)</em></p>
<hr />
<h3 id="selectors-and-constructors">Selectors and Constructors</h3>
<p><strong>What are the <em>selectors</em> of lists?</strong></p>
<ul>
<li><code>car</code> – to select the first element of a list.</li>
<li><code>cdr</code> – to select the portion of a list containing all but the first element.</li>
</ul>
<p><strong>What is the <em>predicate</em> function to check for an empty list?</strong></p>
<ul>
<li><code>null?</code> – returns <code>#t</code> for the empty list, <code>#f</code> for anything else.</li>
</ul>
<p><strong>What are the <em>constructors</em> for lists?</strong></p>
<ul>
<li><code>list</code> – takes any number of arguments and returns a list with those arguments as its elements.</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb3-1" title="1">(<span class="kw">list</span> (<span class="op">+</span> <span class="dv">2</span> <span class="dv">3</span>) &#39;squash (<span class="op">=</span> <span class="dv">2</span> <span class="dv">2</span>) (<span class="kw">list</span> <span class="dv">4</span> <span class="dv">5</span>) <span class="kw">remainder</span> &#39;zucchini)</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="co">;(5 SQUASH #T (4 5) #&lt;PROCEDURE&gt; ZUCCHINI)</span></a></code></pre></div>
<p><img src="images/list.png" width="400"></p>
<ul>
<li><code>cons</code> – takes two arguments, an element and a list and returns a new list whose <code>car</code> is the first argument and whose <code>cdr</code> is the second.</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb4-1" title="1">(<span class="kw">cons</span> &#39;for &#39;(no one))</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="co">; (FOR NO ONE)</span></a></code></pre></div>
<p><img src="images/cons.png" width="400"></p>
<ul>
<li><code>append</code> – combines the elements of two or more lists into a larger list.</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb5-1" title="1">(<span class="kw">append</span> &#39;(get back) &#39;(the word))</a>
<a class="sourceLine" id="cb5-2" title="2"><span class="co">; (GET BACK THE WORD)</span></a></code></pre></div>
<p><img src="images/append.png" width="400"></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb6-1" title="1">(<span class="kw">list</span> &#39;(i am) &#39;(the walrus))</a>
<a class="sourceLine" id="cb6-2" title="2"><span class="co">; ((I AM) (THE WALRUS))</span></a>
<a class="sourceLine" id="cb6-3" title="3"></a>
<a class="sourceLine" id="cb6-4" title="4">(<span class="kw">cons</span> &#39;(i am) &#39;(the walrus))</a>
<a class="sourceLine" id="cb6-5" title="5"><span class="co">; ((I AM) THE WALRUS)</span></a>
<a class="sourceLine" id="cb6-6" title="6"></a>
<a class="sourceLine" id="cb6-7" title="7">(<span class="kw">append</span> &#39;(i am) &#39;(the walrus))</a>
<a class="sourceLine" id="cb6-8" title="8"><span class="co">; (I AM THE WALRUS)</span></a></code></pre></div>
<hr />
<h3 id="programming-with-lists">Programming with Lists</h3>
<p><strong>How to define <code>praise</code> flavors function with <code>cons</code>?</strong></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb7-1" title="1">(<span class="ex">define</span><span class="fu"> </span>(praise flavors)</a>
<a class="sourceLine" id="cb7-2" title="2">  (<span class="kw">if</span> (<span class="kw">null?</span> flavors)                         <span class="co">; if flavors is empty</span></a>
<a class="sourceLine" id="cb7-3" title="3">      &#39;()                                       <span class="co">; return &#39;()</span></a>
<a class="sourceLine" id="cb7-4" title="4">      (<span class="kw">cons</span> (se (<span class="kw">car</span> flavors) &#39;(is delicious))  <span class="co">; or invoke recursive calls</span></a>
<a class="sourceLine" id="cb7-5" title="5">            (praise (<span class="kw">cdr</span> flavors)))))</a>
<a class="sourceLine" id="cb7-6" title="6"></a>
<a class="sourceLine" id="cb7-7" title="7">(praise &#39;(ginger (ultra chocolate) lychee (rum raisin)))</a>
<a class="sourceLine" id="cb7-8" title="8"><span class="co">; ((GINGER IS DELICIOUS) (ULTRA CHOCOLATE IS DELICIOUS)</span></a>
<a class="sourceLine" id="cb7-9" title="9"><span class="co">;  (LYCHEE IS DELICIOUS) (RUM RAISIN IS DELICIOUS))</span></a></code></pre></div>
<p><strong>How to define a En-Fr <code>translate</code> function with <code>car</code> and <code>cdr</code>?</strong></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb8-1" title="1"></a>
<a class="sourceLine" id="cb8-2" title="2">(<span class="ex">define</span><span class="fu"> </span>(translate wd)</a>
<a class="sourceLine" id="cb8-3" title="3">  (lookup wd &#39;((window fenetre) (book livre) (computer ordinateur) <span class="co">; Invoke function lookup</span></a>
<a class="sourceLine" id="cb8-4" title="4">              (house maison) (closed ferme) (pate pate) (liver foie) <span class="co">; define dictionary</span></a>
<a class="sourceLine" id="cb8-5" title="5">              (faith foi) (weekend (fin de semaine))</a>
<a class="sourceLine" id="cb8-6" title="6">              ((practical joke) attrape) (pal copain))))</a>
<a class="sourceLine" id="cb8-7" title="7"></a>
<a class="sourceLine" id="cb8-8" title="8">(<span class="ex">define</span><span class="fu"> </span>(lookup wd dictionary)</a>
<a class="sourceLine" id="cb8-9" title="9">  (<span class="kw">cond</span> ((<span class="kw">null?</span> dictionary) &#39;(parlez-vous anglais?)) <span class="co">; when dic is empty, return a sentence</span></a>
<a class="sourceLine" id="cb8-10" title="10">        ((<span class="kw">equal?</span> wd (<span class="kw">car</span> (<span class="kw">car</span> dictionary))) <span class="co">; when wd is equal to the car of car of dic</span></a>
<a class="sourceLine" id="cb8-11" title="11">         (<span class="kw">car</span> (<span class="kw">cdr</span> (<span class="kw">car</span> dictionary)))) <span class="co">; return car of cdr of car of dic</span></a>
<a class="sourceLine" id="cb8-12" title="12">        (<span class="kw">else</span> (lookup wd (<span class="kw">cdr</span> dictionary))))) <span class="co">; else invoke recursive call with cdr of dic</span></a>
<a class="sourceLine" id="cb8-13" title="13"></a>
<a class="sourceLine" id="cb8-14" title="14">(translate &#39;computer)</a>
<a class="sourceLine" id="cb8-15" title="15"><span class="co">; ORDINATEUR</span></a>
<a class="sourceLine" id="cb8-16" title="16"></a>
<a class="sourceLine" id="cb8-17" title="17">(translate &#39;(practical joke))</a>
<a class="sourceLine" id="cb8-18" title="18"><span class="co">; ATTRAPE</span></a>
<a class="sourceLine" id="cb8-19" title="19"></a>
<a class="sourceLine" id="cb8-20" title="20">(translate &#39;recursion)</a>
<a class="sourceLine" id="cb8-21" title="21"><span class="co">; (PARLEZ-VOUS ANGLAIS?)</span></a></code></pre></div>
<p><strong>What is the shorthand for <code>car</code> and <code>cdr</code> in scheme?</strong></p>
<p><code>car</code> = <code>a</code> <code>cdr</code> = <code>d</code></p>
<p>And wrap <code>a</code> and <code>d</code> between <code>c</code> and <code>r</code>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb9-1" title="1">(<span class="kw">car</span> (<span class="kw">cdr</span> (<span class="kw">car</span> dictionary)))</a></code></pre></div>
<p>can be writtern in</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb10-1" title="1">(<span class="kw">cadar</span> dictionary)</a></code></pre></div>
<p>The most commonly used of these abbreviations are <code>cadr</code> , which selects the second element of a list; <code>caddr</code> , which selects the third element; and <code>cadddr</code> , which selects the fourth.</p>
<hr />
<h3 id="the-truth-about-sentences">The Truth about Sentences</h3>
<p><strong>What are sentences?</strong></p>
<p><em>Sentences are lists.</em> Sentences are an abstract data type represented by lists. We created the sentence ADT by writing special selectors and constructors that provide a different way of using the same underlying machinery—a different interface, a different metaphor, a different point of view.</p>
<p><strong>What are the three differences between sentences and lists?</strong></p>
<ul>
<li>A sentence can contain only words, not sublists.</li>
<li>Sentence selectors are symmetrical front-to-back.</li>
<li>Sentences and words have the same selectors.</li>
</ul>
<p>From Scheme’s ordinary point of view, an English sentence is just one particular case of a much more general data structure, whereas a <em>symbol</em> is something entirely different.</p>
<blockquote>
<p>As we said in Chapter 5, “symbol” is the official name for words that are neither strings nor numbers.</p>
</blockquote>
<p><strong>How to define <code>first</code> <code>last</code> <code>butfirst</code> <code>butlast</code> for sentences with Scheme list selectors?</strong></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb11-1" title="1">(<span class="ex">define</span><span class="fu"> </span>(first sent)</a>
<a class="sourceLine" id="cb11-2" title="2">  (<span class="kw">car</span> sent))</a>
<a class="sourceLine" id="cb11-3" title="3"></a>
<a class="sourceLine" id="cb11-4" title="4">(<span class="ex">define</span><span class="fu"> </span>(last sent)</a>
<a class="sourceLine" id="cb11-5" title="5">  (<span class="kw">if</span> (<span class="kw">null?</span> (<span class="kw">cdr</span> sent))  <span class="co">; if the sent is null but the first element</span></a>
<a class="sourceLine" id="cb11-6" title="6">      (<span class="kw">car</span> sent)          <span class="co">; return the first element of the sent</span></a>
<a class="sourceLine" id="cb11-7" title="7">      (last (<span class="kw">cdr</span> sent)))) <span class="co">; or invoke the recursive call</span></a>
<a class="sourceLine" id="cb11-8" title="8"></a>
<a class="sourceLine" id="cb11-9" title="9">(<span class="ex">define</span><span class="fu"> </span>(butfirst sent)</a>
<a class="sourceLine" id="cb11-10" title="10">  (<span class="kw">cdr</span> sent))</a>
<a class="sourceLine" id="cb11-11" title="11"></a>
<a class="sourceLine" id="cb11-12" title="12">(<span class="ex">define</span><span class="fu"> </span>(butlast sent)</a>
<a class="sourceLine" id="cb11-13" title="13">  (<span class="kw">if</span> (<span class="kw">null?</span> (<span class="kw">cdr</span> sent))  <span class="co">; if the sent is null but the first element</span></a>
<a class="sourceLine" id="cb11-14" title="14">      &#39;()                 <span class="co">; return &#39;()</span></a>
<a class="sourceLine" id="cb11-15" title="15">      (<span class="kw">cons</span> (<span class="kw">car</span> sent) (butlast (<span class="kw">cdr</span> sent))))) <span class="co">; or add the first element to result</span></a></code></pre></div>
<hr />
<h3 id="higher-order-functions">Higher-Order Functions</h3>
<p><strong>What are the official list versions of <code>every</code> <code>keep</code> and <code>accumulate</code>?</strong></p>
<p><code>map</code> <code>filter</code> and <code>reduce</code></p>
<p><strong>How does <code>map</code> work?</strong></p>
<p><code>map</code> takes two arguments, a function and a list, and returns a list containing the result of applying the function to each element of the list.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb12-1" title="1">(map square &#39;(<span class="dv">9</span> <span class="dv">8</span> <span class="dv">7</span> <span class="dv">6</span>))</a>
<a class="sourceLine" id="cb12-2" title="2"><span class="co">; (81 64 49 36)</span></a>
<a class="sourceLine" id="cb12-3" title="3"></a>
<a class="sourceLine" id="cb12-4" title="4">(map (<span class="kw">lambda</span> (x) (se x x)) &#39;(rocky raccoon))</a>
<a class="sourceLine" id="cb12-5" title="5"><span class="co">; ((ROCKY ROCKY) (RACCOON RACCOON))</span></a>
<a class="sourceLine" id="cb12-6" title="6"></a>
<a class="sourceLine" id="cb12-7" title="7">(every (<span class="kw">lambda</span> (x) (se x x)) &#39;(rocky raccoon))</a>
<a class="sourceLine" id="cb12-8" title="8"><span class="co">; (ROCKY ROCKY RACCOON RACCOON)</span></a>
<a class="sourceLine" id="cb12-9" title="9"></a>
<a class="sourceLine" id="cb12-10" title="10">(map <span class="kw">car</span> &#39;((john lennon) (paul mccartney)</a>
<a class="sourceLine" id="cb12-11" title="11">           (george harrison) (ringo starr)))</a>
<a class="sourceLine" id="cb12-12" title="12"><span class="co">; (JOHN PAUL GEORGE RINGO)</span></a>
<a class="sourceLine" id="cb12-13" title="13"></a>
<a class="sourceLine" id="cb12-14" title="14">(map <span class="kw">even?</span> &#39;(<span class="dv">9</span> <span class="dv">8</span> <span class="dv">7</span> <span class="dv">6</span>))</a>
<a class="sourceLine" id="cb12-15" title="15"><span class="co">; (#F #T #F #T)</span></a>
<a class="sourceLine" id="cb12-16" title="16"></a>
<a class="sourceLine" id="cb12-17" title="17">(map (<span class="kw">lambda</span> (x) (word x x)) &#39;rain)     <span class="co">; &#39;rain is not a list</span></a>
<a class="sourceLine" id="cb12-18" title="18"><span class="co">; ERROR -- INVALID ARGUMENT TO MAP: RAIN</span></a></code></pre></div>
<blockquote>
<p><strong>Where is the name <code>map</code> from?</strong></p>
</blockquote>
<blockquote>
<p>The word “map” may seem strange for this function, but it comes from the mathematical study of functions, in which they talk about a mapping of the domain into the range. In this terminology, one talks about “mapping a function over a set” (a set of argument values, that is), and Lispians have taken over the same vocabulary, except that we talk about mapping over lists instead of mapping over sets.</p>
</blockquote>
<p><strong>How does <code>filter</code> work?</strong></p>
<p><code>filter</code> also takes a function and a list as arguments; it returns a list containing only those elements of the argument list for which the function returns a true value. This is the same as <code>keep</code>, except that the elements of the argument list may be sublists, and their structure is preserved in the result.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb13-1" title="1">(filter (<span class="kw">lambda</span> (flavor) (member? &#39;swirl flavor))</a>
<a class="sourceLine" id="cb13-2" title="2">        &#39;((rum raisin) (root beer swirl) (rocky road) (fudge swirl)))</a>
<a class="sourceLine" id="cb13-3" title="3"><span class="co">; ((ROOT BEER SWIRL) (FUDGE SWIRL))</span></a>
<a class="sourceLine" id="cb13-4" title="4"></a>
<a class="sourceLine" id="cb13-5" title="5">(filter word? &#39;((ultra chocolate) ginger lychee (raspberry sherbet)))</a>
<a class="sourceLine" id="cb13-6" title="6"><span class="co">; (GINGER LYCHEE)</span></a>
<a class="sourceLine" id="cb13-7" title="7"></a>
<a class="sourceLine" id="cb13-8" title="8">(filter (<span class="kw">lambda</span> (nums) (<span class="op">=</span> (<span class="kw">car</span> nums) (<span class="kw">cadr</span> nums)))</a>
<a class="sourceLine" id="cb13-9" title="9">        &#39;((<span class="dv">2</span> <span class="dv">3</span>) (<span class="dv">4</span> <span class="dv">4</span>) (<span class="dv">5</span> <span class="dv">6</span>) (<span class="dv">7</span> <span class="dv">8</span>) (<span class="dv">9</span> <span class="dv">9</span>)))</a>
<a class="sourceLine" id="cb13-10" title="10"><span class="co">; ((4 4) (9 9))</span></a></code></pre></div>
<p><code>filter</code> is not a standard Scheme primitive, but it’s a universal convention; everyone defines it the same way we do.</p>
<p><strong>How does <code>reduce</code> work?</strong></p>
<p><code>reduce</code> is just like <code>accumulate</code> except that it works only on lists, not on words. Neither is a built-in Scheme primitive; both names are seen in the literature. (The name “reduce” is official in the languages APL and Common Lisp, which do include this higher-order function as a primitive.)</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb14-1" title="1">(reduce * &#39;(<span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span>))</a>
<a class="sourceLine" id="cb14-2" title="2"><span class="co">; 120</span></a>
<a class="sourceLine" id="cb14-3" title="3"></a>
<a class="sourceLine" id="cb14-4" title="4">(reduce (<span class="kw">lambda</span> (list1 list2) (<span class="kw">list</span> (<span class="op">+</span> (<span class="kw">car</span> list1) (<span class="kw">car</span> list2))</a>
<a class="sourceLine" id="cb14-5" title="5">                                    (<span class="op">+</span> (<span class="kw">cadr</span> list1) (<span class="kw">cadr</span> list2))))</a>
<a class="sourceLine" id="cb14-6" title="6">        &#39;((<span class="dv">1</span> <span class="dv">2</span>) (<span class="dv">30</span> <span class="dv">40</span>) (<span class="dv">500</span> <span class="dv">600</span>)))</a>
<a class="sourceLine" id="cb14-7" title="7"><span class="co">; (531 642)</span></a></code></pre></div>
<hr />
<h3 id="other-primitives-for-lists">Other Primitives for Lists</h3>
<ul>
<li><code>list?</code> – returns <code>#t</code> if its argument is a list, <code>#f</code> otherwise.</li>
<li><code>equal?</code></li>
<li><code>member</code> – like <code>member?</code> except for two differences: Its second argument must be a list (but can be a structured list); and instead of returning #t it returns the portion of the argument list starting with the element equal to the first argument.</li>
</ul>
<div class="sourceCode" id="cb15"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb15-1" title="1">(<span class="kw">member</span> &#39;d &#39;(a b c d e f g))</a>
<a class="sourceLine" id="cb15-2" title="2"><span class="co">; (D E F G)</span></a>
<a class="sourceLine" id="cb15-3" title="3"></a>
<a class="sourceLine" id="cb15-4" title="4">(<span class="kw">member</span> &#39;h &#39;(a b c d e f g))</a>
<a class="sourceLine" id="cb15-5" title="5"><span class="co">; #F</span></a></code></pre></div>
<p>This is the main example in Scheme of the <em>semipredicate</em> idea that we mentioned earlier in passing. It doesn’t have a question mark in its name because it returns values other than #t and #f , but it works as a predicate because any non-<code>#f</code> value is considered true.</p>
<ul>
<li><code>list-ref</code> – like <code>item</code> execpt it counts items from zero instead of from one and takes its arguments in the other order:</li>
</ul>
<div class="sourceCode" id="cb16"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb16-1" title="1">(<span class="kw">list-ref</span> &#39;(happiness is a warm gun) <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb16-2" title="2"><span class="co">; WARM</span></a></code></pre></div>
<ul>
<li><code>length</code> – the same with <code>count</code> except that it doesn’t work on words.</li>
</ul>
<hr />
<h3 id="association-lists">Association Lists</h3>
<p><strong>What is an association list?</strong></p>
<p>A list of names and corresponding values is called an <em>association list</em>, or an <em>a-list</em>.</p>
<p><strong>How to look up a name in an a-list?</strong></p>
<p>The Scheme primitive <code>assoc</code></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb17-1" title="1">(<span class="kw">assoc</span> &#39;george</a>
<a class="sourceLine" id="cb17-2" title="2">       &#39;((john lennon) (paul mccartney)</a>
<a class="sourceLine" id="cb17-3" title="3">         (george harrison) (ringo starr)))</a>
<a class="sourceLine" id="cb17-4" title="4"><span class="co">; (GEORGE HARRISON)</span></a>
<a class="sourceLine" id="cb17-5" title="5"></a>
<a class="sourceLine" id="cb17-6" title="6">(<span class="kw">assoc</span> &#39;x &#39;((i <span class="dv">1</span>) (v <span class="dv">5</span>) (x <span class="dv">10</span>) (l <span class="dv">50</span>) (c <span class="dv">100</span>) (d <span class="dv">500</span>) (m <span class="dv">1000</span>)))</a>
<a class="sourceLine" id="cb17-7" title="7"><span class="co">; (X 10)</span></a>
<a class="sourceLine" id="cb17-8" title="8"></a>
<a class="sourceLine" id="cb17-9" title="9">(<span class="kw">assoc</span> &#39;ringo &#39;((mick jagger) (keith richards) (brian jones)</a>
<a class="sourceLine" id="cb17-10" title="10">                (charlie watts) (bill wyman)))</a>
<a class="sourceLine" id="cb17-11" title="11"><span class="co">; #F</span></a></code></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb18-1" title="1">(<span class="ex">define</span><span class="fu"> dictionary</span></a>
<a class="sourceLine" id="cb18-2" title="2">&#39;((window fenetre) (book livre) (computer ordinateur)</a>
<a class="sourceLine" id="cb18-3" title="3">  (house maison) (closed ferme) (pate pate) (liver foie)</a>
<a class="sourceLine" id="cb18-4" title="4">  (faith foi) (weekend (fin de semaine))</a>
<a class="sourceLine" id="cb18-5" title="5">  ((practical joke) attrape) (pal copain)))</a>
<a class="sourceLine" id="cb18-6" title="6"></a>
<a class="sourceLine" id="cb18-7" title="7">(<span class="ex">define</span><span class="fu"> </span>(translate wd)</a>
<a class="sourceLine" id="cb18-8" title="8">  (<span class="kw">let</span> ((record (<span class="kw">assoc</span> wd dictionary)))</a>
<a class="sourceLine" id="cb18-9" title="9">    (<span class="kw">if</span> record</a>
<a class="sourceLine" id="cb18-10" title="10">        (<span class="kw">cadr</span> record)</a>
<a class="sourceLine" id="cb18-11" title="11">        &#39;(parlez-vous anglais?))))</a></code></pre></div>
<p><code>assoc</code> returns <code>#f</code> if it can’t find the entry you’re looking for in your association list.</p>
<hr />
<h3 id="functions-that-take-variable-numbers-of-arguments">Functions That Take Variable Numbers of Arguments</h3>
<p><strong>How to use dot <code>.</code> to represent any number of arguments?</strong></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb19-1" title="1">(<span class="ex">define</span><span class="fu"> </span>(increasing? number . rest-of-numbers)</a>
<a class="sourceLine" id="cb19-2" title="2">  (<span class="kw">cond</span> ((<span class="kw">null?</span> rest-of-numbers) <span class="dv">#t</span>)</a>
<a class="sourceLine" id="cb19-3" title="3">        ((<span class="op">&gt;</span> (<span class="kw">car</span> rest-of-numbers) number)</a>
<a class="sourceLine" id="cb19-4" title="4">         (apply increasing? rest-of-numbers))</a>
<a class="sourceLine" id="cb19-5" title="5">        (<span class="kw">else</span> <span class="dv">#f</span>)))</a>
<a class="sourceLine" id="cb19-6" title="6"></a>
<a class="sourceLine" id="cb19-7" title="7">(increasing? <span class="dv">4</span> <span class="dv">12</span> <span class="dv">82</span>)</a>
<a class="sourceLine" id="cb19-8" title="8"><span class="co">; #T</span></a>
<a class="sourceLine" id="cb19-9" title="9"></a>
<a class="sourceLine" id="cb19-10" title="10">(increasing? <span class="dv">12</span> <span class="dv">4</span> <span class="dv">82</span> <span class="dv">107</span>)</a>
<a class="sourceLine" id="cb19-11" title="11"><span class="co">; #F</span></a></code></pre></div>
<p>In listing the formal parameters of a procedure, you can <em>use a dot just before the last parameter to mean that that parameter ( rest-of-numbers in this case) represents any number of arguments, including zero. The value that will be associated with this parameter when the procedure is invoked will be a list whose elements are the actual argument values.</em></p>
<p><em>The number of formal parameters before the dot determines the minimum number of arguments that must be used when your procedure is invoked. There can be only one formal parameter after the dot.</em></p>
<p><strong>How does procedure <code>apply</code> work?</strong></p>
<p><code>apply</code> takes two arguments, a procedure and a list. Apply invokes the given procedure with the elements of the given list as its arguments, and returns whatever value the procedure returns. Therefore, the following two expressions are equivalent:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb20-1" title="1">(<span class="op">+</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>)</a>
<a class="sourceLine" id="cb20-2" title="2"></a>
<a class="sourceLine" id="cb20-3" title="3">(apply <span class="op">+</span> &#39;(<span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>))</a></code></pre></div>
<p><strong>What is a rest parameter?</strong></p>
<p>A parameter that follows a dot and therefore represents a variable number of arguments is called a <em>rest parameter</em>.</p>
<hr />
<h3 id="recursion-on-arbitrary-structured-lists">Recursion on Arbitrary Structured Lists</h3>
<p><strong>If the entire book is stored in a list structure. How to define a function to lookup how many times a word apears in the book?</strong></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb21-1" title="1">(<span class="ex">define</span><span class="fu"> </span>(deep-appearances wd structure)     <span class="co">; higher-order version</span></a>
<a class="sourceLine" id="cb21-2" title="2">  (<span class="kw">if</span> (word? structure)</a>
<a class="sourceLine" id="cb21-3" title="3">      (<span class="kw">if</span> (<span class="kw">equal?</span> structure wd) <span class="dv">1</span> <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb21-4" title="4">      (reduce <span class="op">+</span></a>
<a class="sourceLine" id="cb21-5" title="5">              (map (<span class="kw">lambda</span> (sublist) (deep-appearances wd sublist))</a>
<a class="sourceLine" id="cb21-6" title="6">                    structure))))</a></code></pre></div>
<p><strong>How to define <code>deep-appearances</code> without higher-order procedures?</strong></p>
<p>We deal with the base case—words—just as before. But for lists we do what we often do in trying to simplify a list problem: We divide the list into its first element (its <code>car</code>) and all the rest of its elements (its <code>cdr</code>).</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb22-1" title="1">(<span class="ex">define</span><span class="fu"> </span>(deep-appearances wd structure)    <span class="co">; compact-version</span></a>
<a class="sourceLine" id="cb22-2" title="2">  (<span class="kw">cond</span> ((<span class="kw">equal?</span> wd structure) <span class="dv">1</span>)          <span class="co">; base case: desired word</span></a>
<a class="sourceLine" id="cb22-3" title="3">        ((word? structure) <span class="dv">0</span>)              <span class="co">; base case: other word</span></a>
<a class="sourceLine" id="cb22-4" title="4">        ((<span class="kw">null?</span> structure) <span class="dv">0</span>)              <span class="co">; base case: empty list</span></a>
<a class="sourceLine" id="cb22-5" title="5">        (<span class="kw">else</span> (<span class="op">+</span> (deep-appearances wd (<span class="kw">car</span> structure))</a>
<a class="sourceLine" id="cb22-6" title="6">                 (deep-appearances wd (<span class="kw">cdr</span> structure))))))</a></code></pre></div>
<p><strong>In <code>deep-appearances</code> the desired result is a single number. What if we want to build a new list-of-lists structure? Having used <code>car</code> and <code>cdr</code> to disassemble a structure, we can use <code>cons</code> to build a new one.</strong></p>
<p>For example, we’ll translate our entire book into Pig Latin:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb23-1" title="1">(<span class="ex">define</span><span class="fu"> </span>(deep-pigl structure)</a>
<a class="sourceLine" id="cb23-2" title="2">  (<span class="kw">cond</span> ((word? structure) (pigl structure))</a>
<a class="sourceLine" id="cb23-3" title="3">        ((<span class="kw">null?</span> structure) &#39;())</a>
<a class="sourceLine" id="cb23-4" title="4">        (<span class="kw">else</span> (<span class="kw">cons</span> (deep-pigl (<span class="kw">car</span> structure))</a>
<a class="sourceLine" id="cb23-5" title="5">                    (deep-pigl (<span class="kw">cdr</span> structure))))))</a></code></pre></div>
<p>Compare <code>deep-pigl</code> with an every-pattern list recursion such as <code>praise</code> on page 285. Both look like</p>
<p><code>(cons ( something (car argument)) ( something (cdr argument)))</code></p>
<p>And yet these procedures are profoundly different. <code>praise</code> is a simple left-to-right walk through the elements of a sequence; <code>deep-pigl</code> dives in and out of sublists. The difference is a result of the fact that <code>praise</code> does one recursive call, for the <code>cdr</code> , while <code>deep-pigl</code> does two, for the <code>car</code> as well as the <code>cdr</code>. The pattern exhibited by <code>deep-pigl</code> is called <code>car-cdr</code> recursion. (Another name for it is “tree recursion,” for a reason we’ll see in the next chapter.)</p>
<hr />
<h3 id="pitfalls">Pitfalls</h3>
<ul>
<li><p>Just as we mentioned about the names <code>word</code> and <code>sentence</code> , resist the temptation to use <code>list</code> as a formal parameter. We use <code>lst</code> instead, but other alternatives are capital <code>L</code> or <code>seq</code> (for “sequence”).</p></li>
<li><p>The list constructor <code>cons</code> does not treat its two arguments equivalently. The second one must be the list you’re trying to extend. There is no equally easy way to extend a list on the right (although you can put the new element into a one-element list and use <code>append</code> ). If you get the arguments backward, you’re likely to get funny-looking results that aren’t lists, such as</p></li>
</ul>
<div class="sourceCode" id="cb24"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb24-1" title="1">((<span class="dv">3</span> . <span class="dv">2</span>) . <span class="dv">1</span>)</a></code></pre></div>
<p>The result you get when you <code>cons</code> onto something that isn’t a list is called a <em>pair</em>. It’s sometimes called a “dotted pair” because of what it looks like when printed:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb25-1" title="1">(<span class="kw">cons</span> &#39;a &#39;b)</a>
<a class="sourceLine" id="cb25-2" title="2"><span class="co">; (A . B)</span></a></code></pre></div>
<p>It’s just the printed representation that’s dotted, however; the dot isn’t part of the pair any more than the parentheses around a list are elements of the list. Lists are made of pairs; that’s why <code>cons</code> can construct lists. But we’re not going to talk about any pairs that aren’t part of lists, so you don’t have to think about them at all, except to know that if dots appear in your results you’re consing backward.</p>
<ul>
<li><p>Don’t get confused between lists and sentences. Sentences have no internal structure; the good aspect of this is that it’s hard to make mistakes about building the structure, but the bad aspect is that you might need such a structure. You can have lists whose elements are sentences, but it’s confusing if you think of the same structure sometimes as a list and sometimes as a sentence.</p></li>
<li><p>In reading someone else’s program, it’s easy not to notice that a procedure is making two recursive calls instead of just one. If you notice only the recursive call for the <code>cdr</code>, you might think you’re looking at a sequential recursion.</p></li>
<li><p>If you’re writing a procedure whose argument is a list-of-lists, it may feel funny to let it also accept a word as the argument value. People therefore sometimes insist on a list as the argument, leading to an overly complicated base case. If your base case test says</p></li>
</ul>
<div class="sourceCode" id="cb26"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb26-1" title="1">(word? (<span class="kw">car</span> structure))</a></code></pre></div>
<p>then think about whether you’d have a better-organized program if the base case were</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb27-1" title="1">(word? structure)</a></code></pre></div>
<ul>
<li>Remember that in a deep-structure recursion you may need two base cases, one for reaching an element that isn’t a sublist, and the other for an empty list, with no elements at all. (Our <code>deep-appearances</code> procedure is an example.) Don’t forget the empty-list case.</li>
</ul>
<hr />
<h3 id="exercises-17.1-17.3">Exercises 17.1-17.3</h3>
<p><a href="https://github.com/mengsince1986/Simply-Scheme-exercises/blob/master/SS%20Exercises/Exercises%2017.1-17.3.scm">solutions</a></p>
<h3 id="exercises-17.4-17.16">Exercises 17.4-17.16</h3>
<p><a href="https://github.com/mengsince1986/Simply-Scheme-exercises/blob/master/SS%20Exercises/Exercises%2017.4-17.16.scm">solutions</a></p>
<hr />
<h2 id="chapter-18-trees">Chapter 18 Trees</h2>
<p>The kinds of structures we’ll consider are called <strong><em>trees</em></strong> because they resemble trees in nature:</p>
<p><img src="images/trees.png" width="400"></p>
<p>We’re going to begin by considering a tree as an abstract data type, without thinking about how lists are used to represent trees. For example, we’ll construct trees using a procedure named <code>make-node</code> , as if that were a Scheme primitive.</p>
<h3 id="example-the-world">Example: The World</h3>
<p><img src="images/world-trees.png" width="800"></p>
<p><strong>What is a node?</strong></p>
<p>It will be more useful to think of a node as a structure that includes everything below that circle also: <em>the datum and the children</em>. So when we think of the node for Great Britain, we’re thinking not only of the name “Great Britain,” but also of everything in Great Britain. <em>From this perspective, the root node of a tree includes the entire tree.</em> We might as well say that the node is the tree.</p>
<p><strong>How does the tree constructor work?</strong></p>
<p>The constructor for a tree is actually the constructor for one node, its root node. Our constructor for trees is therefore called <code>make-node</code> . It takes two arguments: <em>the datum and a (possibly empty) list of children.</em></p>
<div class="sourceCode" id="cb28"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb28-1" title="1">(<span class="ex">define</span><span class="fu"> world-tree                                          </span><span class="co">;; painful -to-type version</span></a>
<a class="sourceLine" id="cb28-2" title="2">  (make-node</a>
<a class="sourceLine" id="cb28-3" title="3">   &#39;world</a>
<a class="sourceLine" id="cb28-4" title="4">   (<span class="kw">list</span> (make-node</a>
<a class="sourceLine" id="cb28-5" title="5">          &#39;italy</a>
<a class="sourceLine" id="cb28-6" title="6">          (<span class="kw">list</span> (make-node &#39;venezia &#39;())</a>
<a class="sourceLine" id="cb28-7" title="7">                (make-node &#39;riomaggiore &#39;())</a>
<a class="sourceLine" id="cb28-8" title="8">                (make-node &#39;firenze &#39;())</a>
<a class="sourceLine" id="cb28-9" title="9">                (make-node &#39;roma &#39;())))</a>
<a class="sourceLine" id="cb28-10" title="10">         (make-node</a>
<a class="sourceLine" id="cb28-11" title="11">          &#39;(united states)</a>
<a class="sourceLine" id="cb28-12" title="12">          (<span class="kw">list</span> (make-node &#39;california</a>
<a class="sourceLine" id="cb28-13" title="13">                           (<span class="kw">list</span> (make-node &#39;berkeley &#39;())</a>
<a class="sourceLine" id="cb28-14" title="14">                                 (make-node &#39;(san francisco) &#39;())</a>
<a class="sourceLine" id="cb28-15" title="15">                                 (make-node &#39;gilroy &#39;())))</a>
<a class="sourceLine" id="cb28-16" title="16">                (make-node &#39;massachusetts</a>
<a class="sourceLine" id="cb28-17" title="17">                           (<span class="kw">list</span> (make-node &#39;cambridge &#39;())</a>
<a class="sourceLine" id="cb28-18" title="18">                                 (make-node &#39;amherst &#39;())</a>
<a class="sourceLine" id="cb28-19" title="19">                                 (make-node &#39;sudbury &#39;()))))))))</a></code></pre></div>
<p><strong>How do the tree selectors work?</strong></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb29-1" title="1">(datum world-tree)</a>
<a class="sourceLine" id="cb29-2" title="2"><span class="co">; WORLD</span></a>
<a class="sourceLine" id="cb29-3" title="3"></a>
<a class="sourceLine" id="cb29-4" title="4">(datum (<span class="kw">car</span> (children world-tree)))</a>
<a class="sourceLine" id="cb29-5" title="5"><span class="co">; ITALY</span></a>
<a class="sourceLine" id="cb29-6" title="6"></a>
<a class="sourceLine" id="cb29-7" title="7">(datum (<span class="kw">car</span> (children (<span class="kw">cadr</span> (children world-tree)))))</a>
<a class="sourceLine" id="cb29-8" title="8"><span class="co">; CALIFORNIA</span></a>
<a class="sourceLine" id="cb29-9" title="9"></a>
<a class="sourceLine" id="cb29-10" title="10">(datum (<span class="kw">car</span> (children (<span class="kw">car</span> (children</a>
<a class="sourceLine" id="cb29-11" title="11">                            (<span class="kw">cadr</span> (children world-tree)))))))</a>
<a class="sourceLine" id="cb29-12" title="12"><span class="co">; BERKELEY</span></a></code></pre></div>
<p><code>datum</code> of a tree node returns the datum of that node. <code>children</code> of a node returns a list of the children of the node. (A list of trees is called a <em>forest</em>.)</p>
<p><strong>How to simplify <code>world-tree</code> with <code>leaf</code> and <code>cities</code>?</strong></p>
<div class="sourceCode" id="cb30"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb30-1" title="1">(<span class="ex">define</span><span class="fu"> </span>(leaf datum)</a>
<a class="sourceLine" id="cb30-2" title="2">  (make-node datum &#39;()))</a>
<a class="sourceLine" id="cb30-3" title="3"></a>
<a class="sourceLine" id="cb30-4" title="4">(<span class="ex">define</span><span class="fu"> </span>(cities name-list)</a>
<a class="sourceLine" id="cb30-5" title="5">  (map leaf name-list))</a></code></pre></div>
<p>With these abbreviations the world tree is somewhat easier to define:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb31-1" title="1">(<span class="ex">define</span><span class="fu"> world-tree</span></a>
<a class="sourceLine" id="cb31-2" title="2">  (make-node</a>
<a class="sourceLine" id="cb31-3" title="3">   &#39;world</a>
<a class="sourceLine" id="cb31-4" title="4">   (<span class="kw">list</span> (make-node</a>
<a class="sourceLine" id="cb31-5" title="5">         &#39;italy</a>
<a class="sourceLine" id="cb31-6" title="6">         (cities &#39;(venezia riomaggiore firenze roma)))</a>
<a class="sourceLine" id="cb31-7" title="7">  (make-node</a>
<a class="sourceLine" id="cb31-8" title="8">   &#39;(united states)</a>
<a class="sourceLine" id="cb31-9" title="9">   (<span class="kw">list</span> (make-node</a>
<a class="sourceLine" id="cb31-10" title="10">          &#39;california</a>
<a class="sourceLine" id="cb31-11" title="11">          (cities &#39;(berkeley (san francisco) gilroy)))</a>
<a class="sourceLine" id="cb31-12" title="12">         (make-node</a>
<a class="sourceLine" id="cb31-13" title="13">          &#39;massachusetts</a>
<a class="sourceLine" id="cb31-14" title="14">          (cities &#39;(cambridge amherst sudbury)))</a>
<a class="sourceLine" id="cb31-15" title="15">         (make-node &#39;ohio (cities &#39;(kent)))))</a>
<a class="sourceLine" id="cb31-16" title="16">  (make-node &#39;zimbabwe (cities &#39;(harare hwange)))</a>
<a class="sourceLine" id="cb31-17" title="17">  (make-node &#39;china</a>
<a class="sourceLine" id="cb31-18" title="18">             (cities &#39;(beijing shanghai guangzhou suzhou)))</a>
<a class="sourceLine" id="cb31-19" title="19">  (make-node</a>
<a class="sourceLine" id="cb31-20" title="20">   &#39;(great britain)</a>
<a class="sourceLine" id="cb31-21" title="21">   (<span class="kw">list</span></a>
<a class="sourceLine" id="cb31-22" title="22">    (make-node &#39;england (cities &#39;(liverpool)))</a>
<a class="sourceLine" id="cb31-23" title="23">    (make-node &#39;scotland</a>
<a class="sourceLine" id="cb31-24" title="24">               (cities &#39;(edinburgh glasgow (gretna green))))</a>
<a class="sourceLine" id="cb31-25" title="25">    (make-node &#39;wales (cities &#39;(abergavenny)))))</a>
<a class="sourceLine" id="cb31-26" title="26">  (make-node</a>
<a class="sourceLine" id="cb31-27" title="27">   &#39;australia</a>
<a class="sourceLine" id="cb31-28" title="28">   (<span class="kw">list</span></a>
<a class="sourceLine" id="cb31-29" title="29">    (make-node &#39;victoria (cities &#39;(melbourne)))</a>
<a class="sourceLine" id="cb31-30" title="30">    (make-node &#39;(new south wales) (cities &#39;(sydney)))</a>
<a class="sourceLine" id="cb31-31" title="31">    (make-node &#39;queensland</a>
<a class="sourceLine" id="cb31-32" title="32">               (cities &#39;(cairns (port douglas))))))</a>
<a class="sourceLine" id="cb31-33" title="33">  (make-node &#39;honduras (cities &#39;(tegucigalpa))))))</a></code></pre></div>
<hr />
<h3 id="how-big-is-my-tree">How Big Is My Tree?</h3>
<p><strong>How to count cities in <code>world-tree</code> with <code>count-leaves</code>?</strong></p>
<div class="sourceCode" id="cb32"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb32-1" title="1">(<span class="ex">define</span><span class="fu"> </span>(count-leaves tree)</a>
<a class="sourceLine" id="cb32-2" title="2">  (<span class="kw">if</span> (leaf? tree)</a>
<a class="sourceLine" id="cb32-3" title="3">      <span class="dv">1</span></a>
<a class="sourceLine" id="cb32-4" title="4">      (reduce <span class="op">+</span> (map count-leaves (children tree)))))</a>
<a class="sourceLine" id="cb32-5" title="5"></a>
<a class="sourceLine" id="cb32-6" title="6">(<span class="ex">define</span><span class="fu"> </span>(leaf? node)</a>
<a class="sourceLine" id="cb32-7" title="7">  (<span class="kw">null?</span> (children node)))</a>
<a class="sourceLine" id="cb32-8" title="8"></a>
<a class="sourceLine" id="cb32-9" title="9">(count-leaves world -tree)</a>
<a class="sourceLine" id="cb32-10" title="10"><span class="co">; 27</span></a></code></pre></div>
<hr />
<h3 id="mutual-recursion">Mutual Recursion</h3>
<p><strong>How to write <code>count-leaves</code> by <em>mutual recursion</em>?</strong></p>
<div class="sourceCode" id="cb33"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb33-1" title="1">(<span class="ex">define</span><span class="fu"> </span>(count-leaves tree)</a>
<a class="sourceLine" id="cb33-2" title="2">  (<span class="kw">if</span> (leaf? tree)</a>
<a class="sourceLine" id="cb33-3" title="3">  <span class="dv">1</span></a>
<a class="sourceLine" id="cb33-4" title="4">  (count-leaves-in-forest (children tree))))</a>
<a class="sourceLine" id="cb33-5" title="5"></a>
<a class="sourceLine" id="cb33-6" title="6">(<span class="ex">define</span><span class="fu"> </span>(count-leaves-in-forest forest)</a>
<a class="sourceLine" id="cb33-7" title="7">  (<span class="kw">if</span> (<span class="kw">null?</span> forest)</a>
<a class="sourceLine" id="cb33-8" title="8">  <span class="dv">0</span></a>
<a class="sourceLine" id="cb33-9" title="9">  (<span class="op">+</span> (count-leaves (<span class="kw">car</span> forest))</a>
<a class="sourceLine" id="cb33-10" title="10">     (count-leaves-in-forest (<span class="kw">cdr</span> forest)))))</a></code></pre></div>
<p>Note that <code>count-leaves</code> calls <code>count-leaves-in-forest</code> , and <code>count-leaves-in-forest</code> calls <code>count-leaves</code> . This pattern is called <em>mutual recursion</em>.</p>
<p><strong>How to understand <em>mutual recursion</em> in three different modes?</strong></p>
<ul>
<li>Mode 1</li>
</ul>
<p>Initialization procedure: <code>count-leaves</code></p>
<p>helper procedure: <code>count-leaves-in-forest</code></p>
<p>The helper procedure follows the usual sequential list pattern: Do something to the <code>car</code> of the list, and recursively handle the <code>cdr</code> of the list. Now, what do we have to do to the <code>car</code>? In the usual sequential recursion, the <code>car</code> of the list is something simple, such as a word. What’s special about trees is that here the <code>car</code> is itself a tree, just like the entire data structure we started with. Therefore, we must invoke a procedure whose domain is trees: <code>count-leaves</code>.</p>
<p>This model is built on two ideas. One is the idea of <em>the domain of a function</em>; the reason we need two procedures is that we need one that takes a tree as its argument and one that takes a list of trees as its argument. The other idea is <em>the leap of faith</em>; we assume that the invocation of <code>count-leaves</code> within <code>count-leaves-in-forest</code> will correctly handle each child without tracing the exact sequence of events.</p>
<ul>
<li>Mode 2</li>
</ul>
<p>Because of the <em>two-dimensional</em> nature of trees, in order to visit every node we have to be able to move in two different directions. From a given node we have to be able to move <em>down</em> to its children, but from each child we must be able to move <em>across</em> to its next sibling.</p>
<p><code>count-leaves-in-forest</code>: move from left to right through a list of children.</p>
<p><code>count-leaves</code>: move down one level by invoking <code>children</code>.</p>
<ul>
<li>Mode 3</li>
</ul>
<p>The third model is also based on the two-dimensional nature of trees. Imagine for a moment that each node in the tree has at most one child. In that case, <code>count-leaves</code> could move from the root down to the single leaf with a structure very similar to the actual procedure, but carrying out a sequential recursion:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb34-1" title="1">(<span class="ex">define</span><span class="fu"> </span>(count-leaf tree)</a>
<a class="sourceLine" id="cb34-2" title="2">  (<span class="kw">if</span> (leaf? tree)</a>
<a class="sourceLine" id="cb34-3" title="3">  <span class="dv">1</span></a>
<a class="sourceLine" id="cb34-4" title="4">  (count-leaf (child tree))))</a></code></pre></div>
<p>The trouble with this is that at each downward step there isn’t a single “next” node. Instead of a single path from the root to the leaf, there are multiple paths from the root to many leaves. <em>To make our idea of downward motion through sequential recursion work in a real tree, at each level we must “clone” <code>count-leaves</code> as many times as there are children.</em> <code>Count-leaves-in-forest</code> is the factory that manufactures the clones. It hires one <code>count-leaves</code> little person for each child and accumulates their results.</p>
<p><em>We use the name <strong>tree recursion</strong> for any situation in which a procedure invocation results in more than one recursive call, even if there isn’t an argument that’s a tree.</em> Any structured list-of-lists has a somewhat tree-like, two-dimensional character even though it doesn’t use the formal mechanisms we’re exploring in this chapter. The <code>cdr</code> recursion is a “horizontal” one, moving from one element to another within the same list; the <code>car</code> recursion is a “vertical” one, exploring a sublist of the given list.</p>
<hr />
<h3 id="searching-for-a-datum-in-the-tree">Searching for a Datum in the Tree</h3>
<p>Many tree problems don’t quite fit our higher-order functions. For example, let’s write a predicate <code>in-tree?</code> that takes the name of a place and a tree as arguments and tells whether or not that place is in the tree. It is possible to make it work with <code>filter</code> :</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb35-1" title="1">(<span class="ex">define</span><span class="fu"> </span>(in-tree? place tree)</a>
<a class="sourceLine" id="cb35-2" title="2">  (<span class="kw">or</span> (<span class="kw">equal?</span> place (datum tree))</a>
<a class="sourceLine" id="cb35-3" title="3">      (<span class="kw">not</span> (<span class="kw">null?</span> (filter (<span class="kw">lambda</span> (subtree) (in-tree? place subtree))</a>
<a class="sourceLine" id="cb35-4" title="4">                          (children tree))))))</a></code></pre></div>
<p>This awkward construction also performs unnecessary computation. If the place we’re looking for happens to be in the first child of a node, <code>filter</code> will nevertheless look in all the other children as well. We can do better by replacing the use of <code>filter</code> with a mutual recursion:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb36-1" title="1">(<span class="ex">define</span><span class="fu"> </span>(in-tree? place tree)</a>
<a class="sourceLine" id="cb36-2" title="2">  (<span class="kw">or</span> (<span class="kw">equal?</span> place (datum tree))</a>
<a class="sourceLine" id="cb36-3" title="3">      (in-forest? place (children tree))))</a>
<a class="sourceLine" id="cb36-4" title="4"></a>
<a class="sourceLine" id="cb36-5" title="5">(<span class="ex">define</span><span class="fu"> </span>(in-forest? place forest)</a>
<a class="sourceLine" id="cb36-6" title="6">  (<span class="kw">if</span> (<span class="kw">null?</span> forest)</a>
<a class="sourceLine" id="cb36-7" title="7">      <span class="dv">#f</span></a>
<a class="sourceLine" id="cb36-8" title="8">      (<span class="kw">or</span> (in-tree? place (<span class="kw">car</span> forest))</a>
<a class="sourceLine" id="cb36-9" title="9">          (in-forest? place (<span class="kw">cdr</span> forest)))))</a>
<a class="sourceLine" id="cb36-10" title="10"></a>
<a class="sourceLine" id="cb36-11" title="11">(in-tree? &#39;abergavenny world-tree)</a>
<a class="sourceLine" id="cb36-12" title="12"><span class="co">; #T</span></a>
<a class="sourceLine" id="cb36-13" title="13"></a>
<a class="sourceLine" id="cb36-14" title="14">(in-tree? &#39;abbenay world-tree)</a>
<a class="sourceLine" id="cb36-15" title="15"><span class="co">; #F</span></a>
<a class="sourceLine" id="cb36-16" title="16"></a>
<a class="sourceLine" id="cb36-17" title="17">(in-tree? &#39;venezia (<span class="kw">cadr</span> (children world-tree)))</a>
<a class="sourceLine" id="cb36-18" title="18"><span class="co">; #F</span></a></code></pre></div>
<p>A place is in a tree if one of two conditions holds: the place is the datum at the root of the tree, or the place is (recursively) in one of the child trees of this tree. That’s what <code>in-tree?</code> says. As for <code>in-forest?</code>, it says that a place is in one of a group of trees if the place is in the first tree, or if it’s in one of the remaining trees.</p>
<hr />
<h3 id="locating-a-datum-in-the-tree">Locating a Datum in the Tree</h3>
<p>We’d like to be able to locate a city and find out all of the larger regions that enclose the city. For example, we want to say</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb37-1" title="1">(locate &#39;berkeley world-tree)</a>
<a class="sourceLine" id="cb37-2" title="2"><span class="co">; (WORLD (UNITED STATES) CALIFORNIA BERKELEY)</span></a></code></pre></div>
<div class="sourceCode" id="cb38"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb38-1" title="1">(<span class="ex">define</span><span class="fu"> </span>(locate city tree)</a>
<a class="sourceLine" id="cb38-2" title="2">  (<span class="kw">if</span> (<span class="kw">equal?</span> city (datum tree))</a>
<a class="sourceLine" id="cb38-3" title="3">      (<span class="kw">list</span> city)</a>
<a class="sourceLine" id="cb38-4" title="4">      (<span class="kw">let</span> ((subpath (locate-in-forest city (children tree))))</a>
<a class="sourceLine" id="cb38-5" title="5">        (<span class="kw">if</span> subpath</a>
<a class="sourceLine" id="cb38-6" title="6">            (<span class="kw">cons</span> (datum tree) subpath)</a>
<a class="sourceLine" id="cb38-7" title="7">            <span class="dv">#f</span>))))</a>
<a class="sourceLine" id="cb38-8" title="8"></a>
<a class="sourceLine" id="cb38-9" title="9">(<span class="ex">define</span><span class="fu"> </span>(locate-in-forest city forest)</a>
<a class="sourceLine" id="cb38-10" title="10">  (<span class="kw">if</span> (<span class="kw">null?</span> forest)</a>
<a class="sourceLine" id="cb38-11" title="11">      <span class="dv">#f</span></a>
<a class="sourceLine" id="cb38-12" title="12">      (<span class="kw">or</span> (locate city (<span class="kw">car</span> forest))</a>
<a class="sourceLine" id="cb38-13" title="13">          (locate-in-forest city (<span class="kw">cdr</span> forest)))))</a></code></pre></div>
<p>Compare the structure of <code>locate</code> with that of <code>in-tree?</code>. The helper procedures <code>in-forest?</code> and <code>locate-in-forest</code> are almost identical. The main procedures look different, because <code>locate</code> has a harder job, but both of them check for two possibilities: The city might be the datum of the argument node, or it might belong to one of the child trees.</p>
<hr />
<h3 id="representing-trees-as-lists">Representing Trees as Lists</h3>
<p><strong>How do <code>make-node</code> , <code>datum</code> , and <code>children</code> work?</strong></p>
<div class="sourceCode" id="cb39"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb39-1" title="1">(<span class="ex">define</span><span class="fu"> </span>(make-node datum children)</a>
<a class="sourceLine" id="cb39-2" title="2">  (<span class="kw">cons</span> datum children))</a>
<a class="sourceLine" id="cb39-3" title="3"></a>
<a class="sourceLine" id="cb39-4" title="4">(<span class="ex">define</span><span class="fu"> </span>(datum node)</a>
<a class="sourceLine" id="cb39-5" title="5">  (<span class="kw">car</span> node))</a>
<a class="sourceLine" id="cb39-6" title="6"></a>
<a class="sourceLine" id="cb39-7" title="7">(<span class="ex">define</span><span class="fu"> </span>(children node)</a>
<a class="sourceLine" id="cb39-8" title="8">  (<span class="kw">cdr</span> node))</a></code></pre></div>
<p>In other words, <strong>a tree is a list whose first element is the datum and whose remaining elements are subtrees.</strong></p>
<div class="sourceCode" id="cb40"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb40-1" title="1">world-tree</a>
<a class="sourceLine" id="cb40-2" title="2"></a>
<a class="sourceLine" id="cb40-3" title="3">(WORLD</a>
<a class="sourceLine" id="cb40-4" title="4">   (ITALY (VENEZIA) (RIOMAGGIORE) (FIRENZE) (ROMA))</a>
<a class="sourceLine" id="cb40-5" title="5">   ((UNITED STATES)</a>
<a class="sourceLine" id="cb40-6" title="6">    (CALIFORNIA (BERKELEY) ((SAN FRANCISCO)) (GILROY))</a>
<a class="sourceLine" id="cb40-7" title="7">    (MASSACHUSETTS (CAMBRIDGE) (AMHERST) (SUDBURY))</a>
<a class="sourceLine" id="cb40-8" title="8">    (OHIO (KENT)))</a>
<a class="sourceLine" id="cb40-9" title="9">   (ZIMBABWE (HARARE) (HWANGE))</a>
<a class="sourceLine" id="cb40-10" title="10">   (CHINA (BEIJING) (SHANGHAI) (GUANGSZHOU) (SUZHOW))</a>
<a class="sourceLine" id="cb40-11" title="11">   ((GREAT BRITAIN)</a>
<a class="sourceLine" id="cb40-12" title="12">    (ENGLAND (LIVERPOOL))</a>
<a class="sourceLine" id="cb40-13" title="13">    (SCOTLAND (EDINBURGH) (GLASGOW) ((GRETNA GREEN)))</a>
<a class="sourceLine" id="cb40-14" title="14">    (WALES (ABERGAVENNY)))</a>
<a class="sourceLine" id="cb40-15" title="15">   (AUSTRALIA</a>
<a class="sourceLine" id="cb40-16" title="16">    (VICTORIA (MELBOURNE))</a>
<a class="sourceLine" id="cb40-17" title="17">    ((NEW SOUTH WALES) (SYDNEY))</a>
<a class="sourceLine" id="cb40-18" title="18">    (QUEENSLAND (CAIRNS) ((PORT DOUGLAS))))</a>
<a class="sourceLine" id="cb40-19" title="19">   (HONDURAS (TEGUCIGALPA)))</a></code></pre></div>
<hr />
<h3 id="abstract-data-types">Abstract Data Types</h3>
<p>The procedures <code>make-node</code> , <code>datum</code> , and <code>children</code> define an abstract data type for trees. Using this ADT, we were able to write several useful procedures to manipulate trees before pinning down exactly how a tree is represented as a Scheme list.</p>
<p><strong>Why using ADT-specific selectors and constructors instead of <code>car</code> and <code>cdr</code> makes programs more readable?</strong></p>
<p>Consider this example:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb41-1" title="1">(in-tree? &#39;venezia (<span class="kw">caddr</span> world-tree))</a></code></pre></div>
<p>What does <code>caddr</code> mean in this context? Is the <code>caddr</code> of a tree a datum? A child? A forest? Of course you could work it out by careful reasoning, but the form in which we presented this example originally was much clearer:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb42-1" title="1">(in-tree? &#39;venezia (<span class="kw">cadr</span> (children world-tree)))</a></code></pre></div>
<p>Even better would be</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb43-1" title="1">(in-tree? ’venezia (<span class="kw">list-ref</span> (children world -tree) <span class="dv">1</span>))</a></code></pre></div>
<p><strong>What do <em>respecting</em> the data abstraction and <em>data abstraction violation</em> mean?</strong></p>
<p>Using the appropriate selectors and constructors is called <strong><em>respecting</em></strong> the data abstraction. Failing to use the appropriate selectors and constructors is called a <strong><em>data abstraction violation</em></strong>.</p>
<p>Having defined the selctors and constructors for trees ourselves how do we represent the tree in a different way?</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb44-1" title="1">(<span class="ex">define</span><span class="fu"> </span>(make-node datum children)</a>
<a class="sourceLine" id="cb44-2" title="2">  (<span class="kw">list</span> &#39;the &#39;node &#39;with &#39;datum datum &#39;and &#39;children children))</a>
<a class="sourceLine" id="cb44-3" title="3"></a>
<a class="sourceLine" id="cb44-4" title="4">(<span class="ex">define</span><span class="fu"> </span>(datum node) (<span class="kw">list-ref</span> node <span class="dv">4</span>))</a>
<a class="sourceLine" id="cb44-5" title="5"></a>
<a class="sourceLine" id="cb44-6" title="6">(<span class="ex">define</span><span class="fu"> </span>(children node) (<span class="kw">list-ref</span> node <span class="dv">7</span>))</a>
<a class="sourceLine" id="cb44-7" title="7"></a>
<a class="sourceLine" id="cb44-8" title="8"><span class="op">&gt;</span> (make-node &#39;italy (cities &#39;(venezia riomaggiore firenze roma)))</a>
<a class="sourceLine" id="cb44-9" title="9">(THE NODE WITH DATUM ITALY AND CHILDREN</a>
<a class="sourceLine" id="cb44-10" title="10">     ((THE NODE WITH DATUM VENEZIA AND CHILDREN ())</a>
<a class="sourceLine" id="cb44-11" title="11">      (THE NODE WITH DATUM RIOMAGGIORE AND CHILDREN ())</a>
<a class="sourceLine" id="cb44-12" title="12">      (THE NODE WITH DATUM FIRENZE AND CHILDREN ())</a>
<a class="sourceLine" id="cb44-13" title="13">      (THE NODE WITH DATUM ROMA AND CHILDREN ())))</a></code></pre></div>
<p>You might expect that this change in the representation would require changes to all the procedures we wrote earlier, such as <code>count-leaves</code>. But in fact, those procedures would continue to work perfectly because they don’t see the representation. (They respect the data abstraction.) As long as <code>datum</code> and <code>children</code> find the right information, it doesn’t matter how the trees are stored. <em>All that matters is that the constructors and selectors have to be compatible with each other.</em></p>
<hr />
<h3 id="an-advanced-example-parsing-arithmetic-expressions">An Advanced Example: Parsing Arithmetic Expressions</h3>
<p><strong>What is the goal for <code>parse</code> function?</strong></p>
<p>Scheme uses <em>prefix notation</em>: <code>(+ 3 4)</code>. By contrast, people who aren’t Scheme programmers generally represent arithmetic computations using an <em>infix notation</em>, in which the function symbol goes between two arguments: 3 + 4.</p>
<p>Our goal in this section is to translate an infix arithmetic expression into a tree representing the computation. This translation process is called <em>parsing</em> the expression. For example, we’ll turn the expression</p>
<pre><code>4 + 3 × 7 − 5/(3 + 4) + 6</code></pre>
<p>into the tree</p>
<p><img src="images/computation-tree.png" width="400"></p>
<p><strong>How to define <code>parse</code> program?</strong></p>
<div class="sourceCode" id="cb46"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb46-1" title="1">(<span class="ex">define</span><span class="fu"> </span>(parse expr)</a>
<a class="sourceLine" id="cb46-2" title="2">  (parse-helper expr &#39;() &#39;()))  <span class="co">; invoke parse-helper and set operators and operands as &#39;()</span></a>
<a class="sourceLine" id="cb46-3" title="3"></a>
<a class="sourceLine" id="cb46-4" title="4">(<span class="ex">define</span><span class="fu"> </span>(parse-helper expr operators operands)</a>
<a class="sourceLine" id="cb46-5" title="5">  (<span class="kw">cond</span> ((<span class="kw">null?</span> expr)  <span class="co">; when expr is empty</span></a>
<a class="sourceLine" id="cb46-6" title="6">         (<span class="kw">if</span> (<span class="kw">null?</span> operators)  <span class="co">; if operators is empty</span></a>
<a class="sourceLine" id="cb46-7" title="7">             (<span class="kw">car</span> operands)     <span class="co">; return 1st of operands</span></a>
<a class="sourceLine" id="cb46-8" title="8">             (handle-op &#39;() operators operands)))  <span class="co">; if operators is not empty invoke handle-op</span></a>
<a class="sourceLine" id="cb46-9" title="9">        ((<span class="kw">number?</span> (<span class="kw">car</span> expr))  <span class="co">; when 1st of expr is number</span></a>
<a class="sourceLine" id="cb46-10" title="10">         (parse-helper (<span class="kw">cdr</span> expr)  <span class="co">; invoke parse-helper. delete the 1st of expr</span></a>
<a class="sourceLine" id="cb46-11" title="11">                       operators  <span class="co">; pass the original operator pending list</span></a>
<a class="sourceLine" id="cb46-12" title="12">                       (<span class="kw">cons</span> (make-node (<span class="kw">car</span> expr) &#39;()) operands)))  <span class="co">; make node with the 1st of expr and insert the new node the operands</span></a>
<a class="sourceLine" id="cb46-13" title="13">        ((<span class="kw">list?</span> (<span class="kw">car</span> expr))  <span class="co">; when 1st of expr is a list</span></a>
<a class="sourceLine" id="cb46-14" title="14">         (parse-helper (<span class="kw">cdr</span> expr)  <span class="co">; invoke parse-helper. delete the 1st of expr</span></a>
<a class="sourceLine" id="cb46-15" title="15">                       operators  <span class="co">; pass the original operator pending list</span></a>
<a class="sourceLine" id="cb46-16" title="16">                       (<span class="kw">cons</span> (parse (<span class="kw">car</span> expr)) operands)))  <span class="co">; pass the 1st of expr into operands list</span></a>
<a class="sourceLine" id="cb46-17" title="17">        (<span class="kw">else</span> (<span class="kw">if</span> (<span class="kw">or</span> (<span class="kw">null?</span> operators)  <span class="co">; when the 1st of expr is operator. if operators list is empty</span></a>
<a class="sourceLine" id="cb46-18" title="18">                      (<span class="op">&gt;</span> (precedence (<span class="kw">car</span> expr))  <span class="co">; or the current operator is greater than</span></a>
<a class="sourceLine" id="cb46-19" title="19">                         (precedence (<span class="kw">car</span> operators))))  <span class="co">; the 1st of the operator list (last operator)</span></a>
<a class="sourceLine" id="cb46-20" title="20">                  (parse-helper (<span class="kw">cdr</span> expr)  <span class="co">; invoke parse-helper. delte the 1st of expr</span></a>
<a class="sourceLine" id="cb46-21" title="21">                                (<span class="kw">cons</span> (<span class="kw">car</span> expr) operators)  <span class="co">; add the current operator to the operators list</span></a>
<a class="sourceLine" id="cb46-22" title="22">                                operands)  <span class="co">; pass original operands</span></a>
<a class="sourceLine" id="cb46-23" title="23">                  (handle-op expr operators operands))))) <span class="co">; if the current operator is lower than last operator, invoke handle-op</span></a>
<a class="sourceLine" id="cb46-24" title="24"></a>
<a class="sourceLine" id="cb46-25" title="25">(<span class="ex">define</span><span class="fu"> </span>(handle-op expr operators operands)</a>
<a class="sourceLine" id="cb46-26" title="26">  (parse-helper expr  <span class="co">; invoke parse-helper</span></a>
<a class="sourceLine" id="cb46-27" title="27">                (<span class="kw">cdr</span> operators)  <span class="co">; delete the first element of operators</span></a>
<a class="sourceLine" id="cb46-28" title="28">                (<span class="kw">cons</span> (make-node (<span class="kw">car</span> operators)  <span class="co">; get the first of operators and set it as datum</span></a>
<a class="sourceLine" id="cb46-29" title="29">                                 (<span class="kw">list</span> (<span class="kw">cadr</span> operands) (<span class="kw">car</span> operands)))  <span class="co">; make the children with the 2nd and 1st element of operands</span></a>
<a class="sourceLine" id="cb46-30" title="30">                      (<span class="kw">cddr</span> operands)))) <span class="co">; delete the 1st and 2nd element of operands and insert the new list into the operands</span></a>
<a class="sourceLine" id="cb46-31" title="31"></a>
<a class="sourceLine" id="cb46-32" title="32">(<span class="ex">define</span><span class="fu"> </span>(precedence oper)</a>
<a class="sourceLine" id="cb46-33" title="33">  (<span class="kw">if</span> (member? oper &#39;(<span class="op">+</span> <span class="op">-</span>)) <span class="dv">1</span> <span class="dv">2</span>))</a></code></pre></div>
<p>After building the tree it would be easy to compute the value of the expression. Here is the program to do that:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb47-1" title="1">(<span class="ex">define</span><span class="fu"> </span>(compute tree)</a>
<a class="sourceLine" id="cb47-2" title="2">  (<span class="kw">if</span> (<span class="kw">number?</span> (datum tree))  <span class="co">; if the datum of the tree is number</span></a>
<a class="sourceLine" id="cb47-3" title="3">      (datum tree)  <span class="co">; return the datum number</span></a>
<a class="sourceLine" id="cb47-4" title="4">      ((function-named-by (datum tree))  <span class="co">; if the datum of the tree is operator, invoke function-named-by with the operator to return the scheme operator</span></a>
<a class="sourceLine" id="cb47-5" title="5">         (compute (<span class="kw">car</span> (children tree)))  <span class="co">; get the first element of children as the first operand</span></a>
<a class="sourceLine" id="cb47-6" title="6">         (compute (<span class="kw">cadr</span> (children tree)))))) <span class="co">; get the rest of the children as another operand</span></a>
<a class="sourceLine" id="cb47-7" title="7"></a>
<a class="sourceLine" id="cb47-8" title="8">(<span class="ex">define</span><span class="fu"> </span>(function-named-by oper)</a>
<a class="sourceLine" id="cb47-9" title="9">  (<span class="kw">cond</span> ((<span class="kw">equal?</span> oper &#39;+) <span class="op">+</span>)</a>
<a class="sourceLine" id="cb47-10" title="10">        ((<span class="kw">equal?</span> oper &#39;-) <span class="op">-</span>)</a>
<a class="sourceLine" id="cb47-11" title="11">        ((<span class="kw">equal?</span> oper &#39;*) *)</a>
<a class="sourceLine" id="cb47-12" title="12">        ((<span class="kw">equal?</span> oper &#39;/) <span class="op">/</span>)</a>
<a class="sourceLine" id="cb47-13" title="13">        (<span class="kw">else</span> (error <span class="st">&quot;no such operator as&quot;</span> oper))))</a>
<a class="sourceLine" id="cb47-14" title="14"></a>
<a class="sourceLine" id="cb47-15" title="15">(compute (parse &#39;(<span class="dv">4</span> <span class="op">+</span> <span class="dv">3</span> * <span class="dv">7</span> <span class="op">-</span> <span class="dv">5</span> <span class="op">/</span> (<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>) <span class="op">+</span> <span class="dv">6</span>)))</a>
<a class="sourceLine" id="cb47-16" title="16"><span class="co">; 30.285714285714</span></a></code></pre></div>
<hr />
<h3 id="pitfalls-1">Pitfalls</h3>
<ul>
<li><p>A leaf node is a perfectly good actual argument to a tree procedure, even though the picture of a leaf node doesn’t look treeish because there aren’t any branches. A common mistake is to make the base case of the recursion be a node whose children are leaves, instead of a node that’s a leaf itself.</p></li>
<li><p>The value returned by children is not a tree, but a forest. It’s therefore not a suitable actual argument to a procedure that expects a tree.</p></li>
</ul>
<hr />
<h3 id="exercises-18.1-18.6">Exercises 18.1-18.6</h3>
<p><a href="https://github.com/mengsince1986/Simply-Scheme-exercises/blob/master/SS%20Exercises/Exercises%2018.1-18.6.scm">Solutions</a></p>
<hr />
<h2 id="chapter-19-implementing-higher-order-functions">Chapter 19 Implementing Higher-Order Functions</h2>
<p>This chapter is about writing <em>higher-order procedures</em> — that is, procedures that implement higher-order functions. We are going to study the implementation of <code>every</code>, <code>keep</code>, and so on.</p>
<p>The truly important point made in this chapter is that you aren’t limited to a fixed set of higher-order functions. If you feel a need for a new one, you can implement it.</p>
<hr />
<h3 id="generalizing-patterns">Generalizing Patterns</h3>
<p><strong>How to generalize a pattern to calculate areas for different kinds of shapes?</strong></p>
<p>Suppose we want to find out the areas of several different kinds of shapes, given one linear dimension. A straightforward way would be to do it like this:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb48-1" title="1">(<span class="ex">define</span><span class="fu"> pi </span><span class="fl">3.141592654</span>)</a>
<a class="sourceLine" id="cb48-2" title="2"></a>
<a class="sourceLine" id="cb48-3" title="3">(<span class="ex">define</span><span class="fu"> </span>(square-area r) (* r r))</a>
<a class="sourceLine" id="cb48-4" title="4"></a>
<a class="sourceLine" id="cb48-5" title="5">(<span class="ex">define</span><span class="fu"> </span>(circle-area r) (* pi r r))</a>
<a class="sourceLine" id="cb48-6" title="6"></a>
<a class="sourceLine" id="cb48-7" title="7">(<span class="ex">define</span><span class="fu"> </span>(sphere-area r) (* <span class="dv">4</span> pi r r))</a>
<a class="sourceLine" id="cb48-8" title="8"></a>
<a class="sourceLine" id="cb48-9" title="9">(<span class="ex">define</span><span class="fu"> </span>(hexagon-area r) (* (<span class="kw">sqrt</span> <span class="dv">3</span>) <span class="fl">1.5</span> r r))</a>
<a class="sourceLine" id="cb48-10" title="10"></a>
<a class="sourceLine" id="cb48-11" title="11">(square-area <span class="dv">6</span>)</a>
<a class="sourceLine" id="cb48-12" title="12"><span class="co">; 36</span></a>
<a class="sourceLine" id="cb48-13" title="13"></a>
<a class="sourceLine" id="cb48-14" title="14">(circle-area <span class="dv">5</span>)</a>
<a class="sourceLine" id="cb48-15" title="15"><span class="co">; 78.53981635</span></a></code></pre></div>
<p>We want to generalize the pattern that these four procedures exhibit. Each of these procedures has a particular constant factor built in to its definition. What we’d like instead is one single procedure that lets you choose a constant factor when you invoke it. This new procedure will take a second argument besides the linear dimension <code>r</code> (the radius or side): a <code>shape</code> argument whose value is the desired constant factor.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb49-1" title="1">(<span class="ex">define</span><span class="fu"> </span>(area shape r) (* shape r r))</a>
<a class="sourceLine" id="cb49-2" title="2"></a>
<a class="sourceLine" id="cb49-3" title="3">(<span class="ex">define</span><span class="fu"> square </span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb49-4" title="4"></a>
<a class="sourceLine" id="cb49-5" title="5">(<span class="ex">define</span><span class="fu"> circle </span>pi)</a>
<a class="sourceLine" id="cb49-6" title="6"></a>
<a class="sourceLine" id="cb49-7" title="7">(<span class="ex">define</span><span class="fu"> sphere </span>(* <span class="dv">4</span> pi))</a>
<a class="sourceLine" id="cb49-8" title="8"></a>
<a class="sourceLine" id="cb49-9" title="9">(<span class="ex">define</span><span class="fu"> hexagon </span>(* (<span class="kw">sqrt</span> <span class="dv">3</span>) <span class="fl">1.5</span>))</a>
<a class="sourceLine" id="cb49-10" title="10"></a>
<a class="sourceLine" id="cb49-11" title="11">(area sphere <span class="dv">7</span>)</a>
<a class="sourceLine" id="cb49-12" title="12"><span class="co">; 615.752160184</span></a></code></pre></div>
<p>We started with several procedures. Then we found that they had certain points of similarity and certain differences. In order to write a single procedure that generalizes the points of similarity, we had to use an additional argument for each point of difference. (In this example, there was only one point of difference.)</p>
<p>This idea of using a procedure to generalize a pattern is part of the larger idea of abstraction that we’ve been discussing throughout the book. We notice an algorithm that we need to use repeatedly, and so we separate the algorithm from any particular data values and give it a name.</p>
<hr />
<h3 id="the-every-pattern-revisited">The <code>every</code> Pattern Revisited</h3>
<p><strong>What is <code>every</code> template like?</strong></p>
<div class="sourceCode" id="cb50"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb50-1" title="1">(<span class="ex">define</span><span class="fu"> </span>( every-something sent)</a>
<a class="sourceLine" id="cb50-2" title="2">  (<span class="kw">if</span> (empty? sent)</a>
<a class="sourceLine" id="cb50-3" title="3">      &#39;()</a>
<a class="sourceLine" id="cb50-4" title="4">      (se (_______ (first sent))</a>
<a class="sourceLine" id="cb50-5" title="5">          (every -something (bf sent)))))</a></code></pre></div>
<p><strong>How to define <code>every</code>?</strong></p>
<p>You’ve been writing <code>every</code>-like procedures by filling in the blank with a specific function. To generalize the pattern, we’ll use the trick of adding an argument, as we discussed in the last section.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb51-1" title="1">(<span class="ex">define</span><span class="fu"> </span>(every fn sent)</a>
<a class="sourceLine" id="cb51-2" title="2">  (<span class="kw">if</span> (empty? sent)</a>
<a class="sourceLine" id="cb51-3" title="3">      &#39;()</a>
<a class="sourceLine" id="cb51-4" title="4">      (se (fn (first sent))</a>
<a class="sourceLine" id="cb51-5" title="5">          (every fn (bf sent)))))</a></code></pre></div>
<p>The version shown here does indeed work for words, because <code>first</code> and <code>butfirst</code> work for words. So probably “stuff” would be a better formal parameter than “sent.” (The result from <code>every</code> is always a sentence, because <code>sentence</code> is used to construct the result.)</p>
<hr />
<h3 id="the-difference-between-map-and-every">The Difference between <code>map</code> and <code>every</code></h3>
<p><strong>How to define <code>map</code> procedure?</strong></p>
<div class="sourceCode" id="cb52"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb52-1" title="1">(<span class="ex">define</span><span class="fu"> </span>(map fn lst)</a>
<a class="sourceLine" id="cb52-2" title="2">  (<span class="kw">if</span> (<span class="kw">null?</span> lst)</a>
<a class="sourceLine" id="cb52-3" title="3">      &#39;()</a>
<a class="sourceLine" id="cb52-4" title="4">      (<span class="kw">cons</span> (fn (<span class="kw">car</span> lst))</a>
<a class="sourceLine" id="cb52-5" title="5">            (map fn (<span class="kw">cdr</span> lst)))))</a></code></pre></div>
<p>The structure here is identical to that of <code>every</code>; the only difference is that we use <code>cons</code>, <code>car</code>, and <code>cdr</code> instead of <code>se</code>, <code>first</code> , and <code>butfirst</code>.</p>
<p>One implication of this is that you can’t use <code>map</code> with a word, since it’s an error to take the <code>car</code> of a word.</p>
<p><strong>When is it advantageous to use <code>map</code> instead of <code>every</code>?</strong></p>
<p>Suppose you’re using <code>map</code> with a structured list, like this:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb53-1" title="1">(map (<span class="kw">lambda</span> (flavor) (se flavor &#39;(is great)))</a>
<a class="sourceLine" id="cb53-2" title="2">     &#39;(ginger (ultra chocolate) pumpkin (rum raisin)))</a>
<a class="sourceLine" id="cb53-3" title="3"><span class="co">; ((GINGER IS GREAT) (ULTRA CHOCOLATE IS GREAT)</span></a>
<a class="sourceLine" id="cb53-4" title="4"><span class="co">;  (PUMPKIN IS GREAT) (RUM RAISIN IS GREAT))</span></a>
<a class="sourceLine" id="cb53-5" title="5"></a>
<a class="sourceLine" id="cb53-6" title="6">(every (<span class="kw">lambda</span> (flavor) (se flavor &#39;(is great)))</a>
<a class="sourceLine" id="cb53-7" title="7">       &#39;(ginger (ultra chocolate) pumpkin (rum raisin)))</a>
<a class="sourceLine" id="cb53-8" title="8"><span class="co">; (GINGER IS GREAT ULTRA CHOCOLATE IS GREAT PUMPKIN IS GREAT</span></a>
<a class="sourceLine" id="cb53-9" title="9"><span class="co">;  RUM RAISIN IS GREAT)</span></a></code></pre></div>
<p><strong>Why does <code>map</code> preserve the structure of the sublists while <code>every</code> doesn’t?</strong></p>
<p><code>map</code> uses <code>cons</code> to combine the elements of the result, whereas <code>every</code> uses <code>sentence</code> :</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb54-1" title="1">(<span class="kw">cons</span> &#39;(pumpkin is great)</a>
<a class="sourceLine" id="cb54-2" title="2">      (<span class="kw">cons</span> &#39;(rum raisin is great)</a>
<a class="sourceLine" id="cb54-3" title="3">            &#39;()))</a>
<a class="sourceLine" id="cb54-4" title="4"><span class="co">; ((PUMPKIN IS GREAT) (RUM RAISIN IS GREAT))</span></a>
<a class="sourceLine" id="cb54-5" title="5"></a>
<a class="sourceLine" id="cb54-6" title="6">(se &#39;(pumpkin is great)</a>
<a class="sourceLine" id="cb54-7" title="7">    (se &#39;(rum raisin is great)</a>
<a class="sourceLine" id="cb54-8" title="8">        &#39;()))</a>
<a class="sourceLine" id="cb54-9" title="9"><span class="co">; (PUMPKIN IS GREAT RUM RAISIN IS GREAT)</span></a></code></pre></div>
<hr />
<h3 id="filter"><code>filter</code></h3>
<p><strong>How to define <code>filter</code>?</strong></p>
<div class="sourceCode" id="cb55"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb55-1" title="1">(<span class="ex">define</span><span class="fu"> </span>(filter pred lst)</a>
<a class="sourceLine" id="cb55-2" title="2">  (<span class="kw">cond</span> ((<span class="kw">null?</span> lst) &#39;())</a>
<a class="sourceLine" id="cb55-3" title="3">        ((pred (<span class="kw">car</span> lst))</a>
<a class="sourceLine" id="cb55-4" title="4">         (<span class="kw">cons</span> (<span class="kw">car</span> lst) (filter pred (<span class="kw">cdr</span> lst))))</a>
<a class="sourceLine" id="cb55-5" title="5">        (<span class="kw">else</span> (filter pred (<span class="kw">cdr</span> lst)))))</a></code></pre></div>
<p>Like <code>map</code>, this uses <code>cons</code> as the constructor so that it will work properly on structured lists.</p>
<p>(Aside from the difference between lists and sentences, this is just like the keep template on page 224.)</p>
<hr />
<h3 id="accumulate-and-reduce"><code>accumulate</code> and <code>reduce</code></h3>
<p><strong>How to define accumulate with only two arguments?</strong></p>
<p><em>The trick is that in our <code>reduce</code> and <code>accumulate</code> the base case is a one-element argument</em>, rather than an empty argument. When we’re down to one element in the argument, we just return that element:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb56-1" title="1">(<span class="ex">define</span><span class="fu"> </span>(accumulate combiner stuff)  <span class="co">;; first version</span></a>
<a class="sourceLine" id="cb56-2" title="2">  (<span class="kw">if</span> (empty? (bf stuff))</a>
<a class="sourceLine" id="cb56-3" title="3">      (first stuff)</a>
<a class="sourceLine" id="cb56-4" title="4">      (combiner (first stuff)</a>
<a class="sourceLine" id="cb56-5" title="5">                (accumulate combiner (bf stuff)))))</a></code></pre></div>
<p>This version is a simplification of the one we actually provide. What happens if <code>stuff</code> is empty? This version blows up, since it tries to take the <code>butfirst</code> of stuff immediately. Our final version has a specific check for empty arguments:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb57-1" title="1">(<span class="ex">define</span><span class="fu"> </span>(accumulate combiner stuff)</a>
<a class="sourceLine" id="cb57-2" title="2">  (<span class="kw">cond</span> ((<span class="kw">not</span> (empty? stuff)) (real-accumulate combiner stuff))</a>
<a class="sourceLine" id="cb57-3" title="3">        ((<span class="kw">member</span> combiner (<span class="kw">list</span> <span class="op">+</span> * word se <span class="kw">append</span>))</a>
<a class="sourceLine" id="cb57-4" title="4">         (combiner))</a>
<a class="sourceLine" id="cb57-5" title="5">        (<span class="kw">else</span> (error</a>
<a class="sourceLine" id="cb57-6" title="6">               <span class="st">&quot;Can’t accumulate empty input with that combiner&quot;</span>))))</a>
<a class="sourceLine" id="cb57-7" title="7"></a>
<a class="sourceLine" id="cb57-8" title="8">(<span class="ex">define</span><span class="fu"> </span>(real-accumulate combiner stuff)</a>
<a class="sourceLine" id="cb57-9" title="9">  (<span class="kw">if</span> (empty? (bf stuff))</a>
<a class="sourceLine" id="cb57-10" title="10">      (first stuff)</a>
<a class="sourceLine" id="cb57-11" title="11">      (combiner (first stuff) (real-accumulate combiner (bf stuff)))))</a></code></pre></div>
<p><code>reduce</code> is the same, except that it uses <code>null?</code>, <code>car</code>, and <code>cdr</code>.</p>
<p>As we mentioned in Chapter 8, many of Scheme’s primitive procedures return their identity element when invoked with no arguments. We can take advantage of this; if <code>accumulate</code> is invoked with an empty second argument and one of the procedures <code>+</code>, <code>*</code>, <code>word</code>, <code>sentence</code>, <code>append</code> or <code>list</code>, we invoke the combiner with no arguments to produce the return value.</p>
<p>On the other hand, if <code>accumulate</code>’s combiner argument is something like <code>(lambda (x y) (word x ’- y))</code> or <code>max</code>, then there’s nothing <code>accumulate</code> can return, so we give an error message.</p>
<hr />
<h3 id="robustness">Robustness</h3>
</body>
</html>
